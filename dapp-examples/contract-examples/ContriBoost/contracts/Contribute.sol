// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@klaytn/contracts/token/ERC20/IERC20.sol";
import { VRFConsumerBase } from "@bisonai/orakl-contracts/src/v0.1/VRFConsumerBase.sol";
import { IVRFCoordinator } from "@bisonai/orakl-contracts/src/v0.1/interfaces/IVRFCoordinator.sol";

contract ContributionSystem is VRFConsumerBase {
    // Structure to define a participant
    struct Participant {
        uint id;                // Unique identifier for the participant
        uint depositAmount;     // Amount deposited by the participant
        uint lastDepositTime;   // Time of the last deposit made by the participant
        bool exists;            // Flag to check if participant exists
        bool receivedFunds;     // Flag to check if the participant has received funds
    }

    address public host;                        // Address of the contract deployer
    uint public dayRange;                       // Duration of each segment in days
    uint public expectedNumber;                 // Expected number of participants
    uint public currentSegment;                 // Current segment
    uint public contributionAmount;             // Expected amount each participant should contribute
    address public tokenAddress;                // Address of the ERC20 token used for contributions
    mapping(address => Participant) public participants;  // Mapping of participant addresses to their Participant struct
    address[] public participantList;           // Array to store addresses of all participants
    uint public totalAmount;                    // Total amount of tokens in the contract

    // Events
    event Deposit(address indexed participant, uint amount);
    event FundsTransferred(address indexed from, address indexed to, uint amount);
    event SegmentEnd(uint segmentNumber);
    event RandomNumberGenerated(uint256 randomNumber);

    IVRFCoordinator private COORDINATOR;        // Instance of the VRF Coordinator
    bytes32 private keyHash;                    // Key hash for VRF request
    uint256 private fee;                        // Fee required to make a request
    uint256 public sRandomWord;                 // Random number generated by VRF

    // Constructor
    constructor(
        address coordinator,
        bytes32 _keyHash,
        uint256 _fee,
        uint _dayRange,
        uint _expectedNumber,
        uint _contributionAmount,
        address _tokenAddress
    ) VRFConsumerBase(coordinator) {
        host = msg.sender;
        dayRange = _dayRange;
        expectedNumber = _expectedNumber;
        contributionAmount = _contributionAmount;
        tokenAddress = _tokenAddress; // Initialize token address
        currentSegment = 1;
        COORDINATOR = IVRFCoordinator(coordinator);
        keyHash = _keyHash;
        fee = _fee;
        totalAmount = IERC20(tokenAddress).balanceOf(address(this));  // Update total amount
    }

    // Modifier: Only host
    modifier onlyHost() {
        require(msg.sender == host, "Only the host can call this function");
        _;
    }

    // Modifier: Can join
    modifier canJoin() {
        require(!participants[msg.sender].exists, "You are already a participant");
        _;
    }

    // Allow participants to join the system
    function join() external payable canJoin {
        Participant storage participant = participants[msg.sender];
        participant.id = participantList.length + 1;
        participant.exists = true;
        participantList.push(msg.sender);
        emit Deposit(msg.sender, msg.value);
    }

    // Allow participants to deposit funds into the contract
    function deposit(uint _amount) external {
        Participant storage participant = participants[msg.sender];
        require(participant.exists, "You are not a participant");
        require(block.timestamp >= participant.lastDepositTime + dayRange * 1 days, "You can only deposit once per segment");

        // Transfer tokens from sender to contract
        require(IERC20(tokenAddress).transferFrom(msg.sender, address(this), _amount), "Token transfer failed");
        require(_amount == contributionAmount, "Please send the exact deposit amount");

        participant.depositAmount += _amount;
        participant.lastDepositTime = block.timestamp;
        emit Deposit(msg.sender, _amount);
    }

    // Distribute funds to a random participant at the end of each segment
    function distributeFunds() external onlyHost {
        require(participantList.length == expectedNumber, "Expected number of participants not reached");
        require(currentSegment <= expectedNumber, "All segments have been completed");

        // Calculate 2% share for the host
        uint hostShare = totalAmount * 2 / 100;
        payable(msg.sender).transfer(hostShare);
        
        // Deduct host share from the total amount
        totalAmount -= hostShare;

        // Request a random number from the VRF Coordinator
        requestRandomWords(keyHash, 0, 300000, 1);
    }

    // Request a random number from the VRF Coordinator
    function requestRandomWords(
        bytes32 _keyHash,
        uint64 _accId,
        uint32 _callbackGasLimit,
        uint32 _numWords
    ) public returns (uint256 requestId) {
        requestId = COORDINATOR.requestRandomWords(_keyHash, _accId, _callbackGasLimit, _numWords);
    }

    // Callback function that fulfills the random number request and transfers funds to the randomly chosen participant
    function fulfillRandomWords(uint256 /* requestId */, uint256[] memory _randomWords) internal override {
        sRandomWord = _randomWords[0];
        // Select a random participant who hasn't received funds yet
        address randomParticipant = participantList[sRandomWord % participantList.length];
        while (participants[randomParticipant].receivedFunds) {
            randomParticipant = participantList[sRandomWord % participantList.length];
        }

        // Transfer remaining funds to the random participant
        require(IERC20(tokenAddress).transfer(randomParticipant, totalAmount), "Token transfer failed");
        participants[randomParticipant].receivedFunds = true;
        emit FundsTransferred(address(this), randomParticipant, totalAmount);

        // Increment segment count
        currentSegment++;

        // If all segments have been completed, reset segment count and emit event
        if (currentSegment > expectedNumber) {
            currentSegment = 1;
            emit SegmentEnd(expectedNumber);
        }
    }

    // Returns a random participant from the participantList
    function getRandomParticipant() internal view returns (address) {
        uint randIndex = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, blockhash(block.number - 1)))) % participantList.length;
        return participantList[randIndex];
    }

    // Allow the contract host to withdraw remaining funds
    function withdraw() external onlyHost {
        require(IERC20(tokenAddress).transfer(host, totalAmount), "Token transfer failed");
    }
}
